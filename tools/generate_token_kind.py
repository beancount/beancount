#!/usr/bin/env python3
"""Generate Rust LeafNodeKind/NonTerminalNodeKind/NodeKind enums from node-types.json.

Usage:
    python scripts/generate_token_kind.py

workaround of https://github.com/tree-sitter/tree-sitter/issues/3276
"""

import json
import re
from pathlib import Path
from typing import Any
from typing import Dict

ROOT = Path(__file__, "../..").resolve()
NODE_TYPES_PATH = ROOT / "crates" / "beancount-tree-sitter" / "src" / "node-types.json"
OUT_PATH = ROOT / "crates" / "beancount-tree-sitter" / "src" / "node_kind.rs"


def to_pascal(name: str) -> str:
    parts = [p for p in re.split(r"[^A-Za-z0-9]+", name) if p]
    if not parts:
        return "Unknown"
    ident = "".join(p[:1].upper() + p[1:] for p in parts)
    if ident[0].isdigit():
        ident = f"N{ident}"
    return ident


def is_terminal(node: Dict[str, Any]) -> bool:
    """Heuristically select terminal/named token kinds."""
    if not node.get("named", False):
        return False
    if node.get("subtypes"):
        return False
    if node.get("children"):
        return False
    fields = node.get("fields")
    if fields:
        # If there are any declared fields, treat it as non-terminal
        return False
    return True


impl = """
impl<'a> PartialEq<NodeKind> for &tree_sitter::Node<'a> {
  fn eq(&self, other: &NodeKind) -> bool {
    &NodeKind::from(self.kind()) == other
  }
}

impl<'a> PartialEq<LeafNodeKind> for &tree_sitter::Node<'a> {
  fn eq(&self, other: &LeafNodeKind) -> bool {
    &LeafNodeKind::from(self.kind()) == other
  }
}

impl<'a> PartialEq<NonTerminalNodeKind> for &tree_sitter::Node<'a> {
  fn eq(&self, other: &NonTerminalNodeKind) -> bool {
    &NonTerminalNodeKind::from(self.kind()) == other
  }
}

impl<'a> PartialEq<NodeKind> for tree_sitter::Node<'a> {
  fn eq(&self, other: &NodeKind) -> bool {
    &NodeKind::from(self.kind()) == other
  }
}
"""


def generate_enum(enum_name: str, names: list[str]) -> list[str]:
    variants = [to_pascal(name) for name in names]

    lines = [
        "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]",
        f"pub enum {enum_name} {{",
    ]
    lines += [f"  {v}," for v in variants]
    lines.append("  Unknown,")
    lines.append("}")
    lines.append("")
    lines.append(f"impl From<&str> for {enum_name} {{")
    lines.append("  fn from(name: &str) -> Self {")
    lines.append("    match name {")
    lines += [
        f'      "{name}" => {enum_name}::{variant},'
        for name, variant in zip(names, variants)
    ]
    lines.append(f"      _ => {enum_name}::Unknown,")
    lines.append("     }")
    lines.append("  }")
    lines.append("}")
    lines.append("")
    lines.append(f"impl {enum_name} {{")
    lines.append("  pub fn name(&self) -> &'static str {")
    lines.append("    match self {")
    lines += [
        f'      {enum_name}::{variant} => "{name}",'
        for name, variant in zip(names, variants)
    ]
    lines.append(f'      {enum_name}::Unknown => "<unknown>",')
    lines.append("    }")
    lines.append("  }")
    lines.append("}")
    lines.append("")

    return lines


def main() -> None:
    data = json.loads(NODE_TYPES_PATH.read_text(encoding="utf-8"))
    token_names = sorted({n["type"] for n in data if is_terminal(n)})
    non_terminal_names = sorted(
        {n["type"] for n in data if n.get("named", False) and n["type"] not in token_names}
    )
    all_names = sorted(set(token_names) | set(non_terminal_names))

    lines = [
        "// @generated by scripts/generate_token_kind.py; do not edit.",
        "// To regenerate, run: python scripts/generate_token_kind.py",
        impl,
    ]
    lines += generate_enum("LeafNodeKind", token_names)
    lines += generate_enum("NonTerminalNodeKind", non_terminal_names)
    lines += generate_enum("NodeKind", all_names)

    OUT_PATH.write_bytes(("\n".join(lines).strip() + "\n").encode())


if __name__ == "__main__":
    main()
