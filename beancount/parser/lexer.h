// beancount/parser/lexer.h generated by reflex 3.0.1 from beancount/parser/lexer.l

#ifndef REFLEX_BEANCOUNT_PARSER_LEXER_H
#define REFLEX_BEANCOUNT_PARSER_LEXER_H
#define yyIN_HEADER 1
#define REFLEX_VERSION "3.0.1"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_bison_bridge        true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_extra_type          yyextra_t*
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_full                true
#define REFLEX_OPTION_header_file         "beancount/parser/lexer.h"
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_never_interactive   true
#define REFLEX_OPTION_noinput             true
#define REFLEX_OPTION_nostdinit           true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "beancount/parser/lexer.cpp"
#define REFLEX_OPTION_params              PyObject* builder
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_unicode             true
#define REFLEX_OPTION_warn                true
#define REFLEX_OPTION_yylineno            true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 32 "beancount/parser/lexer.l"


#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include "beancount/parser/macros.h"
#include "beancount/parser/grammar.h"

typedef void* yyscan_t;
typedef struct _yyextra_t yyextra_t;

struct _yyextra_t {
  /* The Python file object to read from. */
  PyObject* in;

  /* The filename being tokenized. */
  PyObject* filename;

  /* The encoding to use for converting strings. */
  const char* encoding;

  /* A reference to the beancount.core.number.MISSING object */
  PyObject* missing_obj;
};

#define YY_USER_ACTION                                          \
    {                                                           \
        yylloc.file_name = yyget_extra(yyscanner)->filename;    \
    }

#define YY_EXTERN_C extern "C"

C_BEGIN_DECLS

/**
 * Allocate a new scanner object including private data.
 *
 * This encapsulates the native yylex_init_extra() API.
 */
yyscan_t yylex_new(void);

/**
 * Free scanner object including private data.
 *
 * This encapsulated the native yylex_destroy() API. Python objects
 * references stored in the @scanner are decremented.
 */
yyscan_t yylex_free(yyscan_t scanner);

/**
 * Initialize scanner private data.
 *
 * Setup @scanner to read from the Python file-like object @file. Set
 * the reported file name to @filename, if not NULL and not None.
 * Otherwise try to obtain the file name from the @name attribute of
 * the @file object. If this fails, use the empty string. @encoding is
 * used to decode strings read from the input file, if not NULL,
 * otherwise the default UTF-8 encoding is used. Python objects
 * references are incremented. It is safe to call this multiple times.
 */
void yylex_initialize(PyObject* file, PyObject* filename, int lineno,
                      const char* encoding, PyObject* missing_obj, yyscan_t scanner);

/**
 * Read from a io.IOBase Python object into a buffer.
 */
size_t pyfile_read_into(PyObject *file, char *buf, size_t max_size);

C_END_DECLS



#ifdef __cplusplus

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
#line 21 "beancount/parser/lexer.l"

    virtual size_t LexerInput(char *s, size_t n) {
        PyObject* in = yyget_extra(this)->in;
        if (!in) {
            return 0;
        }
        return pyfile_read_into(in, s, n);
    }

 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual void yylloc_update(YYLTYPE& yylloc)
  {
    yylloc.first_line = static_cast<unsigned int>(matcher().lineno());
    yylloc.first_column = static_cast<unsigned int>(matcher().columno());
    yylloc.last_line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.last_column = static_cast<unsigned int>(matcher().columno_end());
  }
  virtual int yylex(void)
  {
    LexerError("yyFlexLexer::yylex invoked but %option bison-bridge and/or bison-locations is used");
    yyterminate();
  }
  virtual int yylex(YYSTYPE& yylval, YYLTYPE& yylloc, PyObject* builder);
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON BRIDGE LOCATIONS                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

typedef void *yyscan_t;
typedef yyFlexLexer yyscanner_t;

#ifndef YY_EXTERN_C
#define YY_EXTERN_C
#endif

#else // !__cplusplus

typedef void *yyscan_t;

#undef YY_EXTERN_C
#define YY_EXTERN_C

#ifndef yy_size_t
#define yy_size_t size_t
#endif

YY_EXTERN_C char *yyget_text(yyscan_t);
YY_EXTERN_C yy_size_t yyget_leng(yyscan_t);
YY_EXTERN_C int yyget_lineno(yyscan_t);
YY_EXTERN_C void yyset_lineno(int, yyscan_t);
YY_EXTERN_C FILE *yyget_in(yyscan_t);
YY_EXTERN_C void yyset_in(FILE*, yyscan_t);
YY_EXTERN_C int yyget_debug(yyscan_t);
YY_EXTERN_C void yyset_debug(int, yyscan_t);
YY_EXTERN_C yyextra_t* yyget_extra(yyscan_t);
YY_EXTERN_C void yyset_extra(yyextra_t*, yyscan_t);

#endif // __cplusplus

YY_EXTERN_C int yylex(YYSTYPE*, YYLTYPE*, yyscan_t, PyObject* builder);
YY_EXTERN_C void yylex_init(yyscan_t*);
YY_EXTERN_C void yylex_init_extra(yyextra_t*, yyscan_t*);
YY_EXTERN_C void yylex_destroy(yyscan_t);

#endif
